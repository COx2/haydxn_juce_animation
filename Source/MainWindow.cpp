/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic outline for a simple desktop window.

  ==============================================================================
*/

#include "MainWindow.h"
#include "Animation/TimerBasedAnimator.h"
#include "Animation/AnimatedValueTree.h"

static TimerBasedAnimator animator(20); // the main animator

class ColoredComponent : public Component
{
public:
    ColoredComponent() {}
    void paint(Graphics& g) override
    {
        g.setColour(Colours::blue);
        g.fillAll();
    }
};

//==============================================================================

// Really rubbish test class to control the size of a component.
// no effort taken here to be safe or nice.

class RubbishAnimator	:	public AnimatedValueTree
{
public:
	
    static const Identifier Angle;
	static const Identifier Width;
	static const Identifier Height;

	RubbishAnimator (Component* target_)
	:	AnimatedValueTree ("test"),
		target(target_)
	{
		
	}
	
	~RubbishAnimator ()
	{
		
	}
	
	void refreshValues ()
	{
        node.setProperty(Angle, angle, nullptr);
		node.setProperty(Width, target->getWidth(), nullptr);
		node.setProperty(Height, target->getHeight(), nullptr);
	}
	
	void applyValueTreeChanges (const ValueTree& node)
	{
        angle = node.getProperty(Angle);
		int w = node.getProperty(Width);
		int h = node.getProperty(Height);
		target->setSize (w, h);

        auto bounds = target->getBounds();
        auto cx = bounds.getCentreX();
        auto cy = bounds.getCentreY();
        target->setTransform(AffineTransform::rotation(angle, cx, cy));
	}
	
private:
	float angle;
	Component* target;
	
};

const Identifier RubbishAnimator::Angle = "angle";
const Identifier RubbishAnimator::Width = "width";
const Identifier RubbishAnimator::Height = "height";



class TestComp	:	public Component,
					public Button::Listener
{
public:
	
	TestComp ()
	:	rubbish(&button), rubbish2(&comp2)
	{
		rubbish.setAnimator (&animator);
        rubbish2.setAnimator (&animator);

		button.setButtonText ("Test");
		button.setClickingTogglesState (true);
		button.setBounds (50,50,100,60);
		addAndMakeVisible(&button);
		button.addListener (this);

        comp2.setBounds (300,50,100,50);
        addAndMakeVisible(&comp2);
	}
	
	~TestComp ()
	{
		
	}
	
	void paint (Graphics& g)
	{
		g.fillAll (Colours::hotpink);
	}
	
	void buttonClicked (Button* b)
	{
		if (b == &button)
		{
            {
                double newH, newW;
                if (button.getToggleState())
                {
                    newH = 100;
                    newW = 200;
                }
                else
                {
                    newH = 50;
                    newW = 50;
                }
                double d = .3;

                rubbish.refreshValues (); // make sure we're holding the current values
                //TODO: perhaps change to using a AnimatedValueSet instead, where the
                // values can have sources which directly wrap existing data, removing
                // the need to manually refresh the local state.
                rubbish.animateValueTo (RubbishAnimator::Width.toString(), newW, d);
                rubbish.animateValueTo (RubbishAnimator::Height.toString(), newH, d);
            }
            {
                float newA;
                if (button.getToggleState())
                {
                    newA = 3.1415926*2;
                }
                else
                {
                    newA = 0;
                }
                double d = 100;

                rubbish2.refreshValues (); // make sure we're holding the current values
                //TODO: perhaps change to using a AnimatedValueSet instead, where the
                // values can have sources which directly wrap existing data, removing
                // the need to manually refresh the local state.
                rubbish2.animateValueTo (RubbishAnimator::Angle.toString(), newA, d);
            }
		}
	}
	
private:
	
	RubbishAnimator rubbish;
    RubbishAnimator rubbish2;

	TextButton button;
    ColoredComponent comp2;
};


//==============================================================================
MainAppWindow::MainAppWindow()
    : DocumentWindow (JUCEApplication::getInstance()->getApplicationName(),
                      Colours::lightgrey,
                      DocumentWindow::allButtons)
{
	TestComp* comp = new TestComp();
	setContentOwned(comp, false);
    centreWithSize (500, 400);
    setVisible (true);
}

MainAppWindow::~MainAppWindow()
{
}

void MainAppWindow::closeButtonPressed()
{
    JUCEApplication::getInstance()->systemRequestedQuit();
}
